package com.tyron.completion;

import com.tyron.completion.lookup.LookupElement;
import com.tyron.completion.lookup.WeighingContext;

import org.jetbrains.annotations.ApiStatus;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import org.jetbrains.kotlin.com.intellij.openapi.application.ApplicationManager;
import org.jetbrains.kotlin.com.intellij.openapi.progress.ProgressManager;
import org.jetbrains.kotlin.com.intellij.openapi.util.Key;
import org.jetbrains.kotlin.com.intellij.util.Consumer;
import org.jetbrains.kotlin.com.intellij.util.containers.ContainerUtil;

import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.atomic.AtomicBoolean;

public abstract class CompletionService {

    /**
     * A "weigher" extension key (see {@link Weigher}) to sort completion items by priority and move the heaviest to the top of the Lookup.
     */
    public static final Key<CompletionWeigher> RELEVANCE_KEY = Key.create("completion");

    public static CompletionService getCompletionService() {
        return ApplicationManager.getApplication().getService(CompletionService.class);
    }


    /**
     * Run all contributors until any of them returns false or the list is exhausted. If {@code from} parameter is not null, contributors
     * will be run starting from the next one after that.
     */
    public void getVariantsFromContributors(final CompletionParameters parameters,
                                            @Nullable final CompletionContributor from,
                                            final Consumer<? super CompletionResult> consumer) {
        getVariantsFromContributors(parameters, from, createMatcher(suggestPrefix(parameters), false), consumer);
    }

    protected void getVariantsFromContributors(CompletionParameters parameters,
                                               @Nullable CompletionContributor from,
                                               PrefixMatcher matcher, Consumer<? super CompletionResult> consumer) {
        getVariantsFromContributors(parameters, from, matcher, consumer, null);
    }

    protected void getVariantsFromContributors(CompletionParameters parameters,
                                               @Nullable CompletionContributor from,
                                               PrefixMatcher matcher, Consumer<? super CompletionResult> consumer,
                                               CompletionSorter customSorter) {
        final List<CompletionContributor> contributors = CompletionContributor.forParameters(parameters);

        for (int i = contributors.indexOf(from) + 1; i < contributors.size(); i++) {
            ProgressManager.checkCanceled();
            CompletionContributor contributor = contributors.get(i);

            CompletionResultSet result = createResultSet(parameters, consumer, contributor, matcher);
            if (customSorter != null) {
                result = result.withRelevanceSorter(customSorter);
            }
            getVariantsFromContributor(parameters, contributor, result);
            if (result.isStopped()) {
                return;
            }
        }
    }

    protected void getVariantsFromContributor(CompletionParameters params, CompletionContributor contributor, CompletionResultSet result) {
        contributor.fillCompletionVariants(params, result);
    }

    protected abstract CompletionResultSet createResultSet(CompletionParameters parameters, Consumer<? super CompletionResult> consumer,
                                                           @NotNull CompletionContributor contributor, PrefixMatcher matcher);

    protected abstract String suggestPrefix(CompletionParameters parameters);

    @NotNull
    protected abstract PrefixMatcher createMatcher(String prefix, boolean typoTolerant);

    @Nullable
    public abstract CompletionProcess getCurrentCompletion();

    /**
     * The main method that is invoked to collect all the completion variants
     * @param parameters Parameters specifying current completion environment
     * @param consumer The consumer of the completion variants. Pass an instance of {@link BatchConsumer} if you need to receive information
     *                 about item batches generated by each completion contributor.
     */
    public void performCompletion(CompletionParameters parameters, Consumer<? super CompletionResult> consumer) {
        final Set<LookupElement> lookupSet = Collections.synchronizedSet(new HashSet<>());
        AtomicBoolean typoTolerant = new AtomicBoolean();

        BatchConsumer<CompletionResult> batchConsumer = new BatchConsumer<CompletionResult>() {
            @Override
            public void startBatch() {
                if (consumer instanceof BatchConsumer) {
                    ((BatchConsumer<?>)consumer).startBatch();
                }
            }

            @Override
            public void endBatch() {
                if (consumer instanceof BatchConsumer) {
                    ((BatchConsumer<?>)consumer).endBatch();
                }
            }

            @Override
            public void consume(CompletionResult result) {
//                if (typoTolerant.get() && result.getLookupElement().getAutoCompletionPolicy() != AutoCompletionPolicy.NEVER_AUTOCOMPLETE) {
//                    result = result.withLookupElement(AutoCompletionPolicy.NEVER_AUTOCOMPLETE.applyPolicy(result.getLookupElement()));
//                }
                if (lookupSet.add(result.getLookupElement())) {
                    consumer.consume(result);
                }
            }
        };
        String prefix = suggestPrefix(parameters);
        getVariantsFromContributors(parameters, null, createMatcher(prefix, false), batchConsumer);
        if (lookupSet.isEmpty() && prefix.length() > 2) {
            typoTolerant.set(true);
            getVariantsFromContributors(parameters, null, createMatcher(prefix, true), batchConsumer);
        }
    }

    public abstract CompletionSorter defaultSorter(CompletionParameters parameters, PrefixMatcher matcher);

    public abstract CompletionSorter emptySorter();

    @ApiStatus.Internal
    public static boolean isStartMatch(LookupElement element, WeighingContext context) {
        return getItemMatcher(element, context).isStartMatch(element);
    }

    @ApiStatus.Internal
    public static PrefixMatcher getItemMatcher(LookupElement element, WeighingContext context) {
        PrefixMatcher itemMatcher = context.itemMatcher(element);
        String pattern = context.itemPattern(element);
        if (!pattern.equals(itemMatcher.getPrefix())) {
            return itemMatcher.cloneWithPrefix(pattern);
        }
        return itemMatcher;
    }
}
